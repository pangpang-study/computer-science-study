## 쿠키
- HTTP는 stateless 프로토콜이다. 그래서 사용자의 인증 여부를 비롯해 정보를 저장하지 못한다.
- Cookie는 상태를 저장하기 위해 도입. 사용자를 식별할 수 있는 정보를 HTTP Set-Cookie 헤더에 주입하여 요청이 들어왔을 때, 쿠키를 판별하여 인증

### 취약점
- XSS(Cross Site Scripting)공격등을 통해 쿠키 탈취가 가능하다.
    - HttpOnly 옵션을 넣어서 브라우저(Javascript)를 통해 쿠키를 스크립트로 조작하지 못하게 만들면 해결가능.
- 하지만 그래도 여전히 네트워크 패킷을 직접 감청하는 것은 해결하지 못함.

## 세션
- 세션은 쿠키에 직접 사용자 정보가 들어가는 것이 보안상 위험하기에 서버에서 정보를 관리하자는 개념에서 등장.
    - 쿠키는 클라이언트, 세션은 서버.
- 서버측에서는 세션 디비를 통해서 관리.
- 그래서 세션ID만 Cookie에 넣어서 통신
- 즉, 사용자 정보는 서버가 관리해서 쿠키 탈취로 인한 사용자 개인정보 탈취 방지.

### 취약점
- 쿠키가 탈취되어서 그대로 해커가 서버에 접속해서 사용자 정보를 탈취할 수 있음. 쿠키보다는 번거로움. 하지만 여전히 불안.
- 쿠키가 중간에 탈취가 되어도 서버측에서 expire time, 쿠키 지속시간 설정등으로 해당 세션을 만료시키면 더 이상 인증되지 않음. 따라서 쿠키가 털릴 것을 대비해서 expire time을 짧게 주면 된다.
    - 그래도 털리는건 어쩔 수 없음.
- HTTP는 본질적으로 stateless인데 서버가 세션을 저장하여 **stateful한 상태**가 되어버림.
- 최근 웹 서비스가 커지며 하나의 서버로는 부하를 감당할 수 없어서 scale-out, MSA가 필요해짐.
    - 분산 서비스마다 세션 디비를 따로 둔다면 인증의 문제가 생긴다 -> 각 세션 **DB간의 동기화**가 필요해짐.
    - 하나의 세션 디비를 두고 사용한다면? **DB write**에서 결국 부하가 일어난다.

## 토큰
- 앞서 말한 쿠키와 세션의 사용에서 발생한 문제를 해결하기 위해 토큰 도입
- 사용자가 첫 인증을 마치면 서버는 클라이언트에게 토큰을 반환.
- 발급된 토큰을 이용하여 다양한 서비스에 인증. 토큰은 주로 시크릿 키를 이용하여 복호화를 통해 사용자 정보와 인증 여부를 얻게 된다.
    - 즉, 매번 세션 디비에 인증 여부를 검사하지 않아도 되서 병목현상이 제거된다.
- 대표적으로 JWT(Json Web Token)이 있다.

### 취약점
- 토큰도 탈취되면 문제되는 것은 동일하다. 그래서 두 가지 종류로 나눠서 관리한다.
    - Access Token: Expire time을 짧게 주고 자주 만료시킨다. 실제로 사용자의 인증에 쓰이는 토큰
    - Refresh Token: Expire time을 길게 준다. Access Token이 만료되면 재발급 하는 용도로 쓰이는 토큰
    - Access Token이 자주 만료되기 때문에 탈취에 대한 문제가 적어지지만 그래도 탈취당하면 답은 없다.
    - Access Token의 만료를 너무 자주 하게 되면 인증 서버에 대한 부하가 커질 수 있다.
- JWT의 경우에는 payload에 사용자 정보를 담기 때문에 탈취되어 복호화가 된다면 쿠키처럼 개인정보 노출에 대한 우려가 있다.
    - 보안을 위해, Access Token은 다른 토큰을 사용하고, API Gateway를 통해 JWT로 교체하는 방식의 아키텍쳐를 구축할 수 있다.

