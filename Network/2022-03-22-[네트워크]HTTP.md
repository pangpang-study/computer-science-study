---
title:  "HTTP"
excerpt: "HTTP에 대하여"
categories:
  - CS
tags:
  - [CS, 네트워크]

toc: true
toc_sticky: true
 
date: 2022-03-22
last_modified_at: 2022-03-22
---

# HTTP란
- HTTP 메시지는 HTTP 서버와 HTTP 클라이언트에 의해 해석이 된다.
- TCP/ IP를 이용하는 응용 프로토콜이다.
(컴퓨터와 컴퓨터간에 데이터를 전송 할 수 있도록 하는 장치로 인터넷이라는 거대한 통신망을 통해 원하는 정보(데이터)를 주고 받는 기능을 이용하는 응용 프로토콜)
- HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다.
(이러한 단점을 해결하기 위해 Cookie와 Session이 등장하였다.)
- HTTP는 연결을 유지하지 않는 프로토콜이기 때문에 요청/응답 방식으로 동작한다.

## http/0.9
- one-line 프로토콜
- 요청으로만 구성 (오직 GET으로만)
- 응답은 바디로만 가능 
- 헤더, 응답, 상태 등의 존재하지 않았음

## http/1.0
- 요청과 응답에 필요한 정보를 담기 위한 헤더 추가
- 버전정보가 요청과 응답에 추가
- 응담에 상태/에러 추가
- html이외에 다양한 컨텐츠 지원

## http/1.1
- 약 1년도 안되어서 바로 1.1이 등장하였다.
    + **하나의 tcp 커넥션당 하나의 컨텐츠만 요청이 가능**
    + 하나의 ip에 여러 도메인 서비스 불가
- 1.0에서 하나의 페이지에 20개의 컨텐츠가 있다면 20개의 커넥션이 필요했다. 
- 이는 서버와 클라이언트 모두에게 많은 과부하를 야기한다. 
- 이를 해결하기 위한 1.1의 특징은 다음과 같다.
    1. 세션유지와 파이프라이닝
    2. 클라이언트 식별과 쿠키 
### 문제점
- FCP : 웹페이지에 접속했을 때 처음 컨텐츠가 뜨기까지 소요되는 시간
- FCP가 1초 미만이어야 웹사이트에 이용자가 오래 머무른다고 알려져 있다. 
- 1.1은 아래의 문제점으로 인해 FCP를 낮추는 것이 어려웠다. 
    1. 프로토콜 자체의 부하
    2. TCP 프로토콜의 한계(slow start)
    3. 파이프라이닝의 비현실적인 비용, head of line blocking 
    4. 패킷의 순서가 보장되는 요청/응답 환경
- TCP를 사용하는 통신에서 패킷은 무조건 정확한 순서대로 처리되어야 한다. 수신 측은 송신 측과 주고받은 시퀀스 번호를 참고하여 패킷을 재조립 해야하기 때문-> 이로인한 head of line blocking이 발생하여 latancy 발생(HTTP/1 과 HTTP/2 둘다 포함).

## http/2
- 만 웹 기술이 발전함에 따라 사진, 동영상 등과 같은 고용량의 멀티미디어 데이터를 전송하는 일이 많아졌고, 모바일 시장이 엄청나게 성장했다. 이에 따라 새로운 버전의 HTTP가 필요하다고 주장
- 이에 구글은 자체적으로 SPDY라는 프로토콜을 개발
### 특징
- Head of line blocking(HOL)
    - HTTP/1.1까지는 한 번에 한 파일밖에 못 보냈다. 그래서 특정 파일의 로딩이 늦어지면 다른 파일까지 줄줄이 느려지는 병목 현상이 생기게 된다. 그래서 여러 파일을 한꺼번에 병렬 전송을 하는 식으로 로딩 시간을 줄이는 방법을 사용한다.
- 중복 헤더의 제거
    - 같은 내용의 헤더를 보낼 경우, 생략해버리는 식으로 처리함으로써 속도를 높이는 방식이다.
- Header compression
    - 이전까지는 HTTP 헤더가 평문이었지만, HTTP/2에서는 헤더를 압축하여 용량 대비 처리 효율성을 높이는 방법을 사용한다. 압축을 하기 때문에 헤더 크기 자체도 크게 줄어든다.
- Server push
    - 특정 파일을 서버에 지정해서 HTTP 전송 시 같이 밀어 넣는 방식이다. 주로 JavaScript나 CSS, 글꼴, 이미지 파일 등을 지정한다.
- Prioritization
    - 웹 페이지를 구성하는 파일의 우선순위를 둘 수 있다. 로딩이 빨리 되어야 하는 파일과 그렇지 않은 파일을 구분해줄 수 있고, 이들 사이에서도 중요도를 차등 배분할 수 있다.

## HTTP/3 UDP 채용
- TCP의 단점을 보완
- UDP를 채용했지만 정확히는 신뢰성을 포기한것이 아닌 UDP를 기반으로 한 QUIC를 사용한다. 
### QUIC
- 암호화가 프로토콜의 일부기능으로 포함되어 있다
- 스트림 연결과 암호화 스펙등을 포함한 모든 핸드쉐이크가 단일 요청/응답으로 끝난다
- 패킷이 개별적으로 암호화 되며, 다른 데이터 부분의 패킷을 기다릴 필요가 없다
- 통신이 멀티플렉싱 되며 이를 통해 HOLB를 극복할 수 있다
- QUIC는 운영체제 커널과 독립적으로 응용 프로그램 공간내에서 구현할 수 있으며, 덕분에 데이터의 이동에 따른 컨텍스트 전환에 의한 오버헤드가 없어진다
- Source Address와 무관하게 서버에 대한 연결을 고유하게 식별하는 연결 식별자가 포함되어 있어, IP주소가 변경되더라도 커넥션을 유지할 수 있다.
- 연결 설정 시 레이턴시 감소
    - QUIC은 TCP를 사용하지 않기 때문에 통신을 시작할 때 번거로운 3 Way Handshake 과정을 거치지 않아도 된다. 클라이언트가 보낸 요청을 서버가 처리한 후 다시 클라이언트로 응답해주는 사이클을 RTT(Round Trip Time)이라고 하는데, TCP는 연결을 생성하기 위해 기본적으로 1 RTT가 필요하고, 여기에 TLS를 사용한 암호화까지 하려고 한다면 TLS의 자체 핸드쉐이크까지 더해져 총 3 RTT가 필요하다.

    - 반면 QUIC은 첫 연결 설정에 1 RTT만 소요된다. 클라이언트가 서버에 어떤 신호를 한번 주고, 서버도 거기에 응답하기만 하면 바로 본 통신을 시작할 수 있다는 것이다. 즉, 연결 설정에 소요되는 시간이 반 정도 밖에 안된다.
