## HTTP 0.9

- HTTP 0.9는 초기 버전, 즉 1.0이 세상에 공개되기 전을 의미한다.
- HTML의 전송 프로토콜. HTML 파일만 전송이 가능했다. 상태 오류 코드도 없었다.
- 요청은 단일라인으로 메소드, 리소스 로 구성된다. 메소드는 GET 밖에 없었다.

```html
GET /home.html

<HTML>
  pangpang study
</HTML>
```

## HTTP 1.0

HTTP 0.9는 너무 제한적이었기 때문에 **확장성**을 위해 정식적인 버전.

- Connectionless/Stateless: 요청 하나에 커넥션 하나 → 매번 새로운 연결로 성능 저하, 서버 부하 비용 상승
- 버전 정보 기입 → `HTTP/1.0`
- 응답 코드와 설명이( `200 OK` ) 응답의 시작 부분에 붙음.
    - 응답 코드와 상태를 이용해서 클라이언트는 다음에 보낼 요청, 혹은 자신의 요청 처리 여부를 알게 됨.
- Request, Response 각각 헤더 도입 -> `메타데이터`를 전송할 수 있게 됨.
    - `Content-Type`에 의해 HTML 외의 다른 데이터가 전송 될 수 있게 됨.

## HTTP 1.1 - 표준 프로토콜이 됨

주요 변경점: 커넥션 유지. 1.0 버전 보다 TCP 세션 유지를 통한 성능 향상

- **Persistent Connection**
   - 지정한 시간(timeout) 동안 커넥션을 닫지 않는 방법. 커넥션을 **재사용** 할 수 있게함. 
   - 문서 내에 임베드 된 여러 리소스들을 커넥션을 새로 따지 않고 재요청 보낼 수 있도록 한다. ex): `<img>`
   - Keep-Alive 헤더
- **Pipelining**
   - 앞선 응답의 처리 완료 여부와 상관 없이 요청을 받음. 즉, 첫 요청이 다 끝나기도 전에 다음 요청을 보낼 수 있게 함. 따라서 커뮤니케이션 Latency를 낮춤
   - 하지만 이 방식은 **Head Of Line Blocking** 의 문제가 있음. 
   - **HOL Blocking**이란 같은 큐에 있는 패킷이 앞의 패킷에 의해 지연되는 것.
   - RFC문서에 의하면 서버는 요청이 들어온 순서대로 처리해야한다고 적혀있고, 이게 HOL blocking의 원인이 된다.
- **Content Negotiation**
   - 동일한 URI에서 서로 다른 버전을 서브(serve)하기 위해 사용하는 메커니즘이다. 
   - 예를 들어 `google.com`을 입력할 때 컨텐츠를 한국에선 한국용을, 영국에선 영국용을 제공하는 것을 말한다.
- **문제점**
   - 연속된 요청에서 Header 구조의 중복 → 쓸데 없이 전송하는 데이터가 커진다.
   - Head Of Line Blocking 발생,
   - 서버가 먼저 데이터를 푸쉬 하지 못한다. 
   - Google의 SPDY, WebSocket등의 확장 프로토콜이 생김.

## HTTP 2 - 멀티플렉싱을 통한 성능 향상

- 주요 변경점: 성능 향상에 초점.
   - **멀티플렉싱**: 동일한 연결(TCP)에서 다중 동시 교환 허용 → 네트워크 리소스 효율적으로 사용, 지연시간 줄임
   - 헤더 필드 압축
   - 요청의 우선순위 지정
   - 서버 푸시 기능
   - 엄밀히 말하면 HTTP 1.1의 변경이 아님. **확장**임. 따라서 기본 HTTP 메소드, 헤더 등 유지된다.

- **멀티플렉싱**
   - **바이너리 프레이밍 계층(Binary Framing Layer)**
      - **스트림(Stream)**: 바이트의 양방향 흐름 단위
      - 메세지(Message): 프레임의 전체 시퀀스
      - **프레임(Frame)**: HTTP2 통신의 최소 단위. 각 최소 단위에서는 하나의 프레임 헤더가 존재한다. 이 헤더를 통해 프레임이 속하는 스트림을 식별.
      - HTTP 메세지를 바이너리 프레임으로 **캡슐화** 했다는 것. 그리고 이걸 캡슐화 해서 TCP로 전송되는 방식을 규정.
   - 기존 HTTP 1.1에서는 여러 병렬처리 요청을 보내면 처리 요청 개수만큼 TCP 커넥션(세션)이 필요. 그러나 2에서는 **단일 TCP에 무제한 양방향 스트림**을 이용. 따라서 여러 요청과 응답들을 순서를 지키지 않고(block하지 않고) 처리할 수 있다. 즉 1.1에서의 문제였던 **HOL Blocking 이 해결**된다.
   - 병렬처리가 어떻게 되는가, 프레임마다 식별할 수 있는 헤더가 있고, 어떤 스트림인지 정보가 있음. 따라서 받는 쪽에서 프레임 식별을 통해 인터리빙(순서 뒤죽박죽) 되어 오는 프레임들을 재조립할 수 있다.
- **헤더 필드 압축**
   - 기존 HTTP 1.1에서 메타 데이터는 항상 텍스트 형태로 전송되었다. 그래서 500~800바이트의 오버헤드가 있었다고 함.
   - HPACK: 허프만 인코딩 + 인덱싱
      - 전송되는 개별 헤더 필드를 허프만 인코딩을 통해 압축한다. 개별 전송 크기를 줄이는 역할을 함.
      - 여기서의 인덱싱은 이미 보낸 값은, 인덱스만 가지고 어떤 값이었는지 판단하도록 하는 방법. 즉, 중복 내용을 계속 보내지 않고, 인덱스만 보낸다는 것. 새로운 값이나, 변경점이 있다면 해당 값은 필드를 보냄. 
      - 이렇게 하기 위해서는 클라이언트, 서버 양측 모두 **공유 압축 테이블**을 갖고 있어야 함.
- Stream Prioritization: 요청 우선순위 설정
   - 스트림을 트리 구조로 부모-자식 관계를 두어 우선순위를 둘 수 있음. 따라서 요청과 응답에 우선순위를 둘 수 있는 것.
- **서버 푸시**
   - 서버 푸시란, 보낸 요청에 대한 응답 뿐아니라, 추가로 다른 리소스까지 전송하는 기능이다.
   - 앞서 1.0 방식에서 발생한 HTML내의 새로운 리소스 요청을 1.1에서 **Persistence Connection**으로 해결했었다. 2에서는 **서버 푸시**를 통해 해결하려고 한 것이다.
   - 설명과 이름만 보면 서버가 단독으로 푸쉬하는 웹소켓(Websocket) 같을 것 같지만 조금 다르다. 웹 소켓에서는 클라이언트와 서버가 연결만 되면 서버가 주기적으로 데이터를 보내주는 등, 독립적으로 푸시가 가능하다. 
   - 반면 서버 푸시는, 클라이언트 요청이 들어와야 한다. 즉, **HTML 파일 요청이 들어오면 거기에 포함되는 모든 리소스를 한방에 보내줄 수 있다는 것**이다. 다중 스트림을 통해 병렬로. 따라서 HTTP1.1보다 페이지 로딩 속도가 엄청 빨라질 수 밖에.

## HTTP 3 - UDP를 통한 성능 향상

- 주요 변경점: **UDP 기반** QUIC 프로토콜 도입
   - TCP의 단점들 상쇄.
   - 멀티플렉싱 여전히 지원

### QUIC
- 전송 계층 프로토콜(L4)
- 왜 UDP 사용? -> TCP단점 상쇄(너무 오래되어서 확장성이 부족, 복잡한 연결설정 오버헤드(3way-handshake, TLS+SSL 연결 설정 등))
   - 데이터 전송에 집중한 프로토콜
   - 별도의 기능이 없고 가볍다. 따라서 원하는 기능을 구현하기 좋다. 즉 백지 상태에 마음대로 구현해서 넣을 수 있었기 때문.
   - UDP에는 송/수신 포트번호, 패킷 길이, 체크섬만 존재한다. UDP를 정리하며 더 알아보겠지만, 체크섬을 정의하지 않아도 되서 신뢰성이 없는거다. 이를 추가로 정의해서 UDP를 확장한다면, 데이터 순서 보장, 전송 보장등 여러 신뢰성을 입힐 수 있다. (ex: rUDP, UDT)
- HTTP/2와 동일하게 멀티 플렉싱 지원
   - HOL Blocking 해결.
- 다방면에서 시간 감축을 했음.
   - 패킷 손실 감지, 재전송 시간 단축.
   - <더 자세한 내용은 추가 PR 바랍니다!>
