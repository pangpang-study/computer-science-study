# 사전 배경 지식

## 1. 메인 메모리(=기억 장치)
데이터, 프로그램, 연산의 중간 결과 등을 일시적 또는 영구적으로 저장하는 장치
접근 속도, 기억 용량, 용도 등에 따라 레지스터, 캐시 메모리, 주기억장치, 보조기억장치로 나누어짐

- 레지스터: 중앙처리장치 내부에 존재하는 기억장치. 접근 시간이 중앙처리장치의 속도와 비슷함.
- 캐시 메모리: 중앙처리장치가 주기억장치에 접근할 때 속도 차이를 줄이기 위해 사용됨. 실행 중인 프로그램의 명령어와 데이터를 저장함. 기억 용량은 작지만 접근 시간이 주기억장치보다 5 ~ 10배 정도 빠름.
- 주기억장치(1차 기억 장치): 중앙처리장치가 직접 데이터를 읽고 쓸 수 있는 장치. 레지스터나 캐시 메모리보다 기억 용량이 큼.
- 보조기억장치(2차 기억 장치): 주기억장치에 비해 접근 시간은 느리지만 기억 용량이 큼. 접근 시간은 주기억장치보다 약 1,000배 정도 느림.

기억장치는 읽고 쓰는 속도에 비례해 가격이 올라가기 때문에, 중앙처리장치에 직접 연결된 기억장치에는 기억 용량이 작고 속도가 빠른 장치를 사용하고, 보조기억장치에는 속도는 느리지만 저렴하고 기억 용량이 큰 것을 사용함.

## 2. 가상 기억 장치(=가상 메모리)
메모리 관리 기법의 하나. 기계에 실제로 이용 가능한 기억 자원을 이상적으로 추상화하여 사용자들에게 매우 큰 (주)메모리로 보이게 만드는 것.

## 3. 프레임
물리 메모리를 일정한 크기로 나눈 블록.
페이지가 하나의 프레임을 할당 받으면, 물리 메모리에 위치하게 됨. 프레임을 할당 받지 못한 페이지들은 외부 저장장치에 저장되며, 이때도 프레임과 같은 크기 단위로 관리됨.

## 4. 단편화(fragmentation)
- 주기억장치에 프로그램을 할당하고 반납하는 과정에서 발생하는 사용되지 않는 작은 조각 공간
- 주기억장치 상에서 빈번하게 기억장소가 할당되고 반납됨에 따라 기억장소들이 조각들로 나누어지는 현상
- 내부 단편화(internal fragmentation): 주기억장치 내 사용자 영역이 실행 프로그램보다 커서 프로그램의 사용 공간을 할당 후 사용되지 않고 남아있는 공간
- 외부 단편화(external fragmentation): 주기억장치 내 사용자 영역보다 실행 프로그램이 커서 프로그램이 할당될 수 없어 사용되지 않고 남아있는 공간
- 단편화의 해결 방법

> 통합 기법
>- 하나의 작업 완료 후 그 사용 영역이 다른 비어있는 분할 공간과 인접해 있는지 점검하여 만약 인접해 있다면 두 개의 빈 분할 공간을 하나로 통합하여 효율성을 높이는 작업

> 압축 기법
> - 주기억장치 내 분산되어 있는 단편화된 비어있는 공간들을 통합하여 하나의 커다란 빈 공간을 만드는 작업.
> - 가비지 컬렉션(Garbage Collection) 작업 이라고도 함.

> 재배치 기법(Relocation)
> - 기억장치 관리에서 Fragmentation을 해결하기 위해 압축을 실행하여 이 과정에서 프로그램의 주소를 새롭게 지정해주는 기법.


# 페이징
## 1. 페이징이란?
- 컴퓨터가 메인 메모리에서 사용하기 위해 2차 기억 장치로부터 데이터를 저장하고 검색하는 메모리 관리 기법. 즉 가상 기억장치를 모두 같은 크기의 블록으로 편성하여 운용하는 기법. 이 때 일정한 크기를 가진 블록을 페이지라고 함. 주소공간을 페이지 단위로 나누고 실제기억공간은 페이지 크기와 같은 프레임으로 나누어 사용함.
- 페이징 기법이 적용된 시스템에서 가상주소는 순서쌍 (p, d)로 나타낼 수 있음. p는 가상기억장치 내에서 참조될 항목이 속해 있는 페이지, d는 페이지 p 내에서 참조될 항목이 위치하고 있는 곳의 변위.
- 어떤 프로세스가 현재 참조하고 있는 페이지가 주기억장치 내에 있다면 그 프로세스는 수행될 수 있음. 반대로, 주기억장치 내에 없다면 그 해당 페이지는 보조기억장치로부터 읽어와서 페이지 프레임의 한 블록에 저장함.
- 페이징 기법으로 메모리를 관리하면, external fragmentation이 발생하지 않음. 물론 internal fragmentation은 발생할 수 있지만, 치명적인 정도가 아니라 괜찮음.

## 2. 페이지 테이블
- 페이지 테이블은 프로세스의 페이지 정보를 저장하고 있으며, 하나의 프로세스는 하나의 페이지 테이블을 가짐. 테이블은 색인과 내용으로 구성되어 있음.

> 색인: 페이지 번호
> 내용: 해당 페이지에 할당된 물리 메모리(프레임)의 시작 주소. 이 시작 주소와 페이지 주소를 결합해 물리 메모리 주소를 알 수 있음.
- 페이지 테이블 엔트리(PTE): 페이지 테이블의 레코드(정보 기록 테이블쯤으로 생각하면 될 듯.)
- PTE의 각 필드에는 일반적으로 다음과 같은 내용이 기록됨.

![image](https://user-images.githubusercontent.com/41022183/147218846-07c675fb-4749-4501-88f2-3858424f4d2b.png)


> 페이지 기본주소(Page base address) (그림상의 PFN:Page frame number/physical frame number로 추정)

>플래그 비트
>> 접근 비트(Accessed bit) : 페이지에 대한 접근이 있었는지를 나타냄.(그림상의 R: reference bit)
>> 변경 비트(Dirty bit) : 페이지 내용의 변경이 있었는지를 나타냄.(그림상의 M:modify bit)
>> 현재 비트(Present bit) : 현재 페이지에 할당된 프레임이 있는지를 나타냄.(그림상의 V:valid bit로 추정)
>> 읽기/쓰기 비트(Read/Write bit) : 읽기/쓰기에 대한 권한을 표시함.(그림상의 prot:protection bits)

## 3. 페이지 테이블 구조
> 1) Linear page table
![image](https://user-images.githubusercontent.com/41022183/147224288-d2586f9b-faaf-46b3-bc21-80442bbd6c98.png)
> - 모든 virtual address의 페이지를 순서대로 다 담아놓은 페이지 테이블. 현대 컴퓨터 환경에서는 사용되지 않음.
> - 페이지 테이블 하나를 저장하기 위해 쓰는 용량이 너무 커서 사용하지 않음.

> 2) Hierarchy page table
![image](https://user-images.githubusercontent.com/41022183/147224379-c2753aeb-73a7-46c5-a2a3-82767369824a.png)
> - Linear page table의 문제를 해결하기 위해 나온 페이지 테이블
> - 안쓰는 page table은 할당하지 않고 있다가 필요할 때만 할당하는 방식
> - outer page table과 page table을 나누어, 사용하는 outer page table만 하위의 page table을 할당해주는 방식
> - 사용하지 않는 page의 경우, page table을 만들지 않아도 되고, outer page table로 손쉽게 관리할 수 있다는 장점이 있음.
![image](https://user-images.githubusercontent.com/41022183/147225750-412d95f4-9106-42de-ae25-7e052bed9ded.png)
> - virtual address는 outer page entry를 나타내는 p1, page table entry의 위치를 나타내는 p2, page frame에서 실제 위치를 나타내는 d로 구성됨.

> 3) Hashed page table
> - 해시 함수를 활용해 VA를 PA로 mapping하는 방법.

> 4) Inverted page table
> PA를 보고 VA를 찾는 방식.(Hashed page table과 반대 개념)
> 프로세스마다 page table을 만들지 않아도 된다는 장점이 있지만, 여러 문제점이 많아 실험적으로만 사용됨.

## 4. TLB(Translation Look-aside Buffer)
- hierarchy page table을 보면, VA를 PA로 변환하는데 굉장히 많은 시간이 필요함.
- 더 빠른 메모리 변환을 하기 위해 생긴 하드웨어에 구현된 표.
![image](https://user-images.githubusercontent.com/41022183/147226334-5ff09883-5d80-4c94-9434-6868a9558a29.png)
- TLB는 vpn과 vpn에 매핑되는 pfn을 가지고 있는데, 만약 어떤 vpn이 TLB에 있으면, page table을 뒤져보지 않고도 바로 pfn을 알 수 있음.(TLB에 있는 경우는 hit, 없는 경우는 miss라고 함.)
- 프로세스가 바뀔 경우, TLB를 모두 flush 해줘야 한다는 문제점이 있음. (TLB에 pid를 추가시켜 flush해주지 않아도 되는 TLB도 많이 사용됨.)

# 메모리 가상화
- 컴퓨터는 멀티 프로그래밍 능력이 필요해졌고, 작업시간 단축을 위해 프로세스를 실행상태, 준비 상태로 나누어 CPU를 효율적으로 사용하게 했음.
- 긴 작업시간 때문에 시분할 방식 사용. 메모리에 저장된 프로세스 정보들을 가져와 실행 시킨 후, 다시 메모리에 저장한 후 다른 프로세스 정보를 가져와 실행시키는 방법.
- 시분할 방식은 메모리가 클수록 느리다는 단점이 존재. 정보 저장과 복원은 빠르지만, 메모리 내용 전체를 디스크에 저장하는 것이 느림.
- 메모리 가상화를 통해 프로세스 전환 시 프로세스를 메모리에 그대로 유지하면서, 운영체제가 시분할 시스템을 효율적으로 구현할 수 있게 함.
- 메모리 가상화: 메모리는 한 개 뿐이지만 프로세스들은 마치 여러 개의 메모리가 있다고 착각하게 만드는 것.
- 여러 개의 프로세스들이 메모리의 일정 부분을 함께 사용하게 됨.
- 다른 프로세스의 메모리 공간에 침입해 데이터 조작이 일어나는 문제가 발생할 수 있음.(Segmentation fault)
- OS는 실제 메모리를 추상화해 프로세스들에게 나눠줌.(address space(주소 공간))
- 프로세스는 자신의 주소 공간에만 접근할 수 있음.

# 1. 메모리 가상화의 목표
1) Transparency(투명성): OS는 실행 중인 프로그램이 메모리가 가상화된다는 사실을 모르게 해야함. 프로그램은 마치 자신에게 하나의 독립적인 실제 메모리가 있는 것처럼 작동하게 해야함.

2) Efficiency(효율성): OS는 시간과 공간적 측면에서 효율적으로 가상화를 수행하도록 해야함. 시간 효율을 위해 OS는 TLB와 같은 하드웨어 지원을 받아야 함.

3) Protection(보안성): OS는 프로세스들로부터 프로세스를 보호하고 OS 자신도 프로세스로부터 보호해야 함.

# 아직 공부하지 못한 부분
- OS 지원을 사용해 메모리 가상화에 필요한 기본 메커니즘들
- 메모리의 여유 공간을 관리하느 방법
- 메모리가 부족할 때 어떻게 처리할 것인지
- 메모리를 함께 사용하는 다른 프로세스로부터 프로세스를 보호하고 OS도 보호하는 방법
