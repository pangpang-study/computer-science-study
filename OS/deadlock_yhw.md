### 교착상태

여러 스레드가 한정된 자원을 사용하려고 서로 경쟁하려고 할때, 이미 자원을 사용중인 상황에서 요청을 한 스레드는 대기 상태로 들어간다.

대기중인 스레드들이 요청한 자원들이 다른 스레드들에 의해 점유되어있고, 다시는 그 상태를 변경할 수 없으면 이를 교착상태라고 한다.



### 시스템 모델

스레드는 자원을 사용하기 전에 반드시 요청해야 하고, 사용 후에는 반드시 방출해야한다. 스레드는 지정된 일을 수행하기 위해 필요한 만큼의 자원을 요청할 수 있다.

1. 요청: 스레드는 자원을 요청한다. 이때 다른 스레드가 자원을 점유하고 있다면, 요청 스레드는 대기
2. 사용: 스레드는 자원에 대한 작업을 수행
3. 방출: 스레드가 자원을 방출



커널영역에서의 스레드의 자원의 요청과 방출은 시스템 콜이다.

매번 운영체제는 스레드가 자원을 요청했는지 그 자원을 할당받았는지를 시스템 테이블을 통해 관리하게된다.(스레드 큐를 사용)

지금부터 우리가 다룰 부분은 네트워크 인터페이스로부터 정보를 읽어오거나, ipc 기능등을 통한 교착상태의 유형이 아닌 자원의 획득과 방출의 시스템 콜에대해서 다루겠다.



### 다중스레드 응용에서의 교착상태

라이브락 - 라이브니스장애 일종

**라이브니스란?** 시스템에서 동시에 실행되는 프로세스가 임계 영역으로 "교대로 전환"해야 한다는 사실에도 불구하고 시스템이 진행되도록 하는 동시성 시스템 속성의 한 집합

**교착상태와의 차이점: 교착상태가 어떤 스레드 집합의 모든 스레드가, 같은 집합에 속한 다른 스레드에 의해서만 발생할 수 있는 이벤트를 기다리면서 봉쇄되는 반면, 라이브락은 실패한 행동을 계속해서 시도할때 발생**

즉, 실패한 작업을 동시에 재시도 할때 발생



예시로 네트워크  충돌시, 이더넷 네트워크가 취하게 되는 접근방법이 예시이다

충돌이 발생한 직후에 패킷을 바로 재전송하지 않고, 임의의 시간을 대기한 후 패킷을 전송해 교착상태를 회피하는 것



### 교착상태의 특성

필요조건들

1. 상호 배제: 최소 하나의 자원이 비공유로 점유되어야 한다. 즉 점유하는 스레드만이 자원을 사용할 수 있다. 다른 스레드가 자원을 요청하게되면 요청한 스레드는 지연...
2. 점유 대기: 스레드는 최소 하나의 자원을 점유한 채, 다른 스레드에 점유된 자원을 추가로 얻기를 원한다면, 반드시 대기해야한다.
3. 비선점: 자원들을 선점할 수 없어야 한다. 즉, 강제적으로 자원을 점유하거나 방출할 수 없고 작업이 끝나야만 방출될 수 있다.
4. 순환대기: 대기하고있는 스레드큐의 집합에서 [1, 2, 3, 4 ... n] 1번이 2번의 자원을 대기하고, 2번이 3번을 ... n번이 1번을 대기하는 상황이여야 한다. (원형)

네 조건이 별개로 독립적으로 이루어지는것은 아니나, 독립적으로 간주하는것이 학습하는데 유용할것이다 ^^

자원 유형이 정확하게 하나의 인스턴스만 가진다면, 교착상태가 발생한 것이다! 

자원할당 그래프를 그렸을때, 사이클이 있다면 교착상태일 수도 있고 아닐 수도 있다.



### 교착상태 처리방법

- 문제를 무시, 교착상태가 시스템에서 발생하지 않는 척하기
- 결코 교착상태가 되지 않도록 보장하기 위하여 교착상태를 예방, 회피하는 프로토콜을 사용
- 교착상태가 되도록 허용한 후 복구

첫 번째 해결안이 리눅스, 윈도우를 포함해 대부분의 운영체제가 사용하는 방법이다.

두 번째는 이상적인 처리방법으로 개발자들은 이를 위해 열심히 공부해야한다....

세 번째는 데이터베이스와 같은 일부 시스템에서 이를 채택하여 교착상태의 발생을 허용하고 복구작업을 수행한다.



어떠한 상황에서는 시스템이 라이브니스 장애로 고생하고 있지만, 교착상태에 있지 않을 수도 있다. 

- 최고 우선순위로 수행되고있는 제어가 운영체제로 돌아가지않는 실시간 스레드와 같은 경우



시스템은 교착상태가 아닌 상황을 위해 수작업 복구 방법을 반드시 가지고 있어야 하며, 교착상태의 회복을 위해 사용할 수도 있다.



### 교착상태 예방

- 상호 배제 조건이 성립되어야 한다. 
  - 읽기 전용파일: 여러 스레드가 파일에 동시에 접근하여도 문제가 발생하지 않는다
  - mutex lock의 경우 여러개의 스레드가 동시에 공유할 수 없다... 문제 발생
- 점유 대기가 발생하지 않게 해야한다.
  - 예시로 스레드가 자원을 전혀 가지고 있지 않을때에만 자원요청이 가능하게끔 하고 추가 자원을 요청할시, 자신이 가지고있는 자원을 무조건 방출해야만 가능하게끔 하는 방법
  - 자원이 할당되었지만 장기간 사용되지 않을 수 있기에 이용률이 좋지 않을 수 있다.
  - 또한 여러개의 자원이 필요한 스레드는 무한정 대기해야 할 수 있다.
- 할당된 자원이 선점되지 않아야 한다.
  - 스레드가 즉시 할당할 수 없는 다른 자원을 요청하면, 현재 점유하고 있는 자원이 선점된다 - 요청한 스레드의 자원들이 묵시적으로 반환되었다고 볼 수 있음
  - 반환된 자원들은 이를 필요로하는 스레드들이 점유하게 되고, 최초에 요청한 스레드는 모든 자원들이 다시 획득되면 요청한 자원과 함께 시작된다.
  - 다른 방법으로는 스레드가 어떤 자원을 요청시 사용 가능한지 점검하여 할당하는 방법이 있다.
  - 데이터베이스 트랜젝션에 주로 쓰이는 방법이고, mutex lock이나 semaphore같은 자원에는 사용이 불가하다
- 순환대기의 경우 가장 실용적인 방법이다.
  - 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 하는 방식



### 교착상태회피

예방의 경우에는 시스템의 이용률이 저하되고, 총처리율이 감소하는 단점이 있다.

자원이 어떻게 요청될지에 대한 추가정보를 제공하도록 요구하는 방법인 회피방법이 있다.

각 스레드의 요청과 방출에 대한 순서를 알고있다면? 교착 상태를피하고자 스레드가 대기해야 하는지의 여부를 결정할 수 있다.

- 회피의 가장 단순한 유형은 스레드가 자신이 필요로 하는 자원의 각 유형의 자원마다 최대수를 선언하도록 미리 요구하는 것이다.
- 각 스레드가 요청할 최대수의 자원의 정보를 알고있다면 교착상태에 들어가지 않을것을 보장하는 알고리즘을 만들 수 있다.
- 안전상태 알고리즘의 경우
  - 필요한 자원을 모두 확인하여 즉시 할당 - 안전상태 -> 안전상태
- 자원 할당 그래프 알고리즘의 경우
  - **예약 간선**을 도입하여 스레드가 현재 할당한 자원, 예약한 자원을 파악하여 예약한 자원의 경우 자원 할당 그래프의 사이클이 없으면 할당해주는 알고리즘
- 은행원 알고리즘의 경우
  - 교착 상태가 발생할 가능성이 있는 불안전 상태의 자원요청은 아예 허가하지 않음



### 교착상태 탐지

필요한 정보를 유지하고 알고리즘을 실행하기 위해서는 시간, 회복을 위한 오버헤드가 필요하다...

- 교착상태가 발생했는지를 결정하는 알고리즘(탐지 알고리즘)

- 교착상태에서 회복하는 알고리즘



**각 자원유형이 한개씩만 있는 경우**

대기그래프라는 자원 할당 그래프의 변형을 통해 상태탐지 알고리즘을 정의 할 수 있다.

- 사이클이 생김? 교착상태가 일어남?(안전상태, 불안전상태)

- 이를 파악하기위해선 대기 그래프를 **유지** 할 필요성이 있음...

- 리눅스에서 실행중인 BCC 툴킷은 PTHREAD MUTEX LOCK과 관련된 교착상태를 감지하는 도구를 제공한다

- DEADLOCK_DETECTOR가 대기그래프를 구성하고, 사이클을 감지하면 안전상태, 불안전상태를 보고한다

  

**각 자원유형이 여러개 있는 경우**

대기그래프는 스레드의 종류마다 자원이 여러개씩 존재하는 상황에서는 사용할 수 없다...

은행원 알고리즘과 마찬가지로 내용이 달라지는 자료구조를 사용한다



**탐지 알고리즘 사용**

그러면 탐지 알고리즘에대해 좀더 자세히 알아보자

탐지 알고리즘은

- 교착상태가 얼마나 자주 일어나는가?
- 몇개의 스레드가 교착상태에 연루되는가?

의 조건을 확인하여 잘 사용하는것이 중요하다.



교착상태란 어떤 스레드가 자원을 요청했는데 그것이 즉시 만족되지 못하는 시점이다.

- 극단적인 방법으로는 스레드의 요청이 즉시 만족되지 않는 불 안전상태일때마다 탐지 알고리즘을 사용하는 것이있다

- 만일 자원이 여러개가 있다면 한개의 요청에서 엄청나게 많은 사이클을 만드는 결과를 초래할 수 있다...

- 자원을 호출할때마다 탐지 알고리즘을 호출하게되면 오버헤드가 너무 크게 된다.

- 이를 해결할 간단안 대안으로는 지정된 시간을 주어 탐지알고리즘을 호출하는 방법도 있다.



### 탐지로부터의 회복

탐지 알고리즘을 이용해 교착상태의 존재여부를 확인했다. 이를 처리하는 방법에는 여러가지가 있다.

- 교착상태가 발생한 것을 운영자에게 통지해, 수작업으로 처리하게 하기
- 시스템이 자동으로 교착상태에서 회복하게 하기
  - CYCLE을 없애기 위해 연루된 한 개 이상의 스레드를 중지
  - 교착상태에 있는 하나 이상의 스레드로부터 자원을 선점(PREEMPT)하기



**프로세스와 스레드를 종료**

프로세스와 스레드를 종료함으로써 모든 자원을 시스템이 회수한다.

- 교착 상태 프로세스를 모두 중지 - 파일 갱신과 같은 프로세스를 실행중이였다면 무결성 보장이 힘들어지기때문에 이를 무작정 중지시키기는 어려운 상황이 생김...
- 교착 상태가 제거될때까지 한 프로세스씩 중지 - 프로세스를 하나씩 종료할때마다 탐지 알고리즘을 이용해 교착상태에서 벗어났는지를 확인해야하므로 상당한 오버헤드가 발생한다...

모든 프로세스를 종료시키는게 아니라 부분적으로 프로세스를 종료시킨다고 했을때 CPU SCHEDULING과 마찬가지로 우선순위를 정해주어야 한다.

1. 프로세스의 우선순위 정하기
2. 수행된 시간과, 지정된 일을 종료하는데 더 필요한 시간
3. 프로세스가 사용한 자원 유형과 수
4. 프로세스가 종료하기 위해 더 필요한 자원의 수
5. 얼마나 많은 프로세스가 종료되어야 하는지



**자원 선점하기**

자원 선점을 통해 교착상태를 제거하고자 한다면 프로세스로부터 자원을 계속 선점해 이를 필요로 하는 프로세스에 주어야 한다. 이를위해 고려해야 할 조건들을 나열해 보았다.

- 희생자 선택
  - 어느 자원과 프로세스를 선점할지?
  - 프로세스 비용의 최소화와 선점의 순서를 결정해야 한다
- 후퇴
  - 가장 단순한 방법이라고 설명
  - 프로세스를 중지시키고 다시 시작하는 것을 의미한다
- 기아상태
  - 자원들이 동일한 프로세스로부터 항상 선점되지 않는다는걸 어떻게 보장할까?
  - 이를위해 비용요소에 후퇴의 횟수를 포함하여 선점하는 방식이 있다
