# 가상 메모리
- 프로세스 전체가 메모리에 올라오지 않아도 실행이 가능하도록 하는것 
- 물리메모리는 페이지로 구성
- 할당된 페이지는 연속적이지 않을 수 있다. 
- 물리페이지 -> 가상페이지 사상 --> MMU
- 스택과 힙 사이에 공산은 스택이나 힙의 공간이 확장될때만 할당 -> sparse 라고 함
- 라이브러리가 존재하는 물리페이지는 읽기 전용 상태로 프로세스 주소공간에 사상되고 이 부분은 모든 프로세스가 공유한다. 
- 페이지는 fork를 통한 프로세스 생성중에 공유될 수 있어 생성 속도를 높인다. 

# 요구 페이징
- 필요한 페이지만 적재한다. 
- 가상페이징에서 일반적으로 사용

## 기본 개념
- 프로세스가 실행되고 있을 떄 일부 페이지는 메모리에 있고 일부 페이지는 보조 저장장치에 있다. 
- 위의 페이지를 구분하기 위해서 하드웨어의 지원이 필요 
- 유효 = 해당 페이지 메모리에 있음 , 무효 = 해당 페이지가 유효하지 않거나 유효하지만 보조 저장장치에 있음 
- 만약 메모리에 없는 페이지 접근하려고 하면? --> 페이지 폴트 
    ### 페이지 폴트 처리(운영체제 한테 날림)
    - 프로세스의 내부 테이블(pcb와 함께 유지)을 뒤져서 해당 메모리가 유효인지 무효인지 확인
    - 무효? -> 프로세스 중단 , 유효? -> 보조저장장치(스왑장치)에서 가져옴 
    - 물리 메모리 free frame을 찾는다
    - 해당 페이지를 free frame으로 할당
    - 할당된 페이지가 메모리에 있다고 페이지 테이블 갱신 ,  프로세스 내부 테이블 수정 
    - 프로세스 이어서 실행
- 새로운 프로세스는 필요한 것 올릴때까지 폴트가 발생
- 프로세스는 참조의 지역성 (locality of reference)가 있어서 요구 페이징 성능 굿 
- 하드웨어의 지원이 필요하다. 
    - 페이지 테이블 : 유효 , 무효 처리 
    - 보조저장장치 : 고성능 디스크, 스왑공간 , 메모리에 없는 페이지 보관
- 이 과정은 cpu와 메모리 , 컴퓨터시스템 사이에 있기 때문에 드러나지 않아야 하고 해결해야 하는 문제가 많기 때문에 매우 복잡하다. 

## 쓰기시 복사 
- fork시에는 부모의 코드를 그대로 가져와야 한다
- 근데 대부분의 fork는 바로 exec를 시행한다. 
- 그럼 복사해온 페이지는 거의 무쓸모다(바로 exec 부분을 실행하므로)
- 따라서 당분간 부모의 페이지를 같이 사용 
- 만약 여러 프로세스중 공유하고 있는 페이지를 쓰려고 할때 해당 페이지를 복사

## 페이지 교체
- 만약 프로세스가 실행되는 동안 페이지 폴트가 발생하고 보조저장장치에 가용한 프레임 공간이 없을때 ?로 처리
- 이때 처리할 수 있는 몇가지 선택 
    - 운영제체가 프로세스를 종료(좋은 방법은 아님)
    - 표준 스와핑(프로세스 통째로 교체 , 안씀)
    - 페이지 스와핑 + 페이지 교체 

    ## 기본적인 페이지 교체 
    - 보조 저장장치에서 필요한 페이지를 찾는다. 
    - 메모리에 비어있는 프레임있으면 그 자리를 사용 
    - 만약 자리가 없다? -> 페이지 교체 알고리즘에 의해 victim 프레임을 선정
    - 해당 victim을 보조저장장치에 기록하고 관련 테이블 수정 
    - 해당 테이블에 새로운 페이지를 불러오고 테이블 수정 
    - 프로세스 재개

- 위의 방식대로 하면 프레임 비울 떄 한번 기록할때 한번 ,총 2번 접근한다. --> **변경비트 사용(dirty bit)** 
- 만약 dirty bit가 설정되어있으면? -> 보조저장장치에 기록 
- 만약 설정안되어있으면? -> 기록하지 않고 제거 


### 요구 페이징에서 가장 중요한 문제 : 프레임 할당 알고리즘 , 페이지 교체 알고리즘 

## FIFO 페이지 교체 
- 메모리에 올라온지 가장 오래된 페이지 교체 
- 그럼 프레임 수를 늘리면 되는거 아닌가? -> 벨라디의 모순 발견 (늘렸는데 페이지 폴트 증가 발견)

## 최적 페이지 교체 
- 벨라디의 모순이 가져온 결과 
- 모든 알고리즘보다 폴트율이 낮고 모순 발생하지 않음
- 가장 오랫동안 사용되지 않을 프레임 제거 
- 예측하는것도 어렵고 구현하기도 어렵다. 
- 그렇다고 다른 알고리즘보다 크게 성능이 비약적이지도 않음
- 언제 사용? -> 비교연구, 성능 체크 목적

## LRU 페이지 교체 
- 가장 오랫동안 사용되지 않은 페이지 교체 
- 페이지 교체정책으로 자주 사용되고 좋은 알고리즘으로 평가됨
- 구현할때 중요한 것은 어떻게 구현하는가? --> 하드웨어의 지원
    ### 구현방법
    - 계수기 : 실제로 참조한 시간을 기록 , 시간이 가작 작은 것이 교체 , 기록하기 위해서 테이블을 참조해야 하고 시간 overflow도 고려해야됨
    - 스택 : 페이지가 참조되면 해당 페이지를 스택에 쌓고 항상 top에 놓이게 되고 bottom을 제거한다. 만약 중간제거가 필요하면?? --> 그래서 구현을 double linked list로 구현한다. : 스택 알고리즘  

## LFU 알고리즘 (잘 안씀)
- 가장 적게 참조하는 페이지를 교체하는 정책
- 만약 한번 집중적으로 참조하고 그 이후로는 안쓰면? -> 예상 빗나감
- 해결방법 : 일정 시간이 지나면 해당 카운터를 시프트 해서 해당 영향력을 지수적으로 감소 


## 프레임 할당
- 최소 프레임수는 아키텍쳐에 따라 다름
- 최대 프레임수는 사용 가능한 물리 메모리양에 따라 결정 
- 균등할당 : 다 똑같이 나눠줌 
- 비례할당 : 요구치에 따라 할당 

## 스레싱 
- 프로세스가 프로세스를 돌리는 시간보다 더 많은 시간을 페이징에 사용하고 있을 때 
### 원인
- 만약 cpu이용률이 낮으면 다중프로그래밍의 정도를 높이기 위해서 새로운 프레임을 추가하려고 한다. 
- 이때 페이지에 대한 고려는 이뤄지지않는다. 
- 만약 다른 프로세스가 더 많은 페이지를 요구해서 페이지 폴트가 발생한다. 
- 근데 교체된 페이지가 다른 프로세스가 사용해야 하는 페이지면 또 다시 페이지 폴트 발생 
- 이러한 페이지 스왑이 계속 이뤄지면서 cpu 이용률이 오히려 더 떨어지게 된다. 
    ### 어느 지점에서는 이용률을 높이기 위해서 다중프로그래밍 정도를 낮춰야 한다.
### 지역교체 알고리즘(우선순위 알고리즘)
- 스레싱을 방지 하기 위해서 각 프로세스가 필요한 최소 프레임을 알아볼 수 있다. -> 지역성 모델
- 프로그램의 구조나 자료구조의 정의의 의해 지역모델의 참조를 지님
- 캐시의 기본 원리이기도 함
- 처음에는 무조건 페이지 폴트가 일어나지만 그 이후에 지역성을 고려한 최소 프레임을 설정
- 지역성의 크기보다 작은 프레임 할당? -> 스레싱

## 현재 관행 : 스레싱과 스와핑을 피하기 위해서 극단적인 조건을 제외하고 충분한 메모리 제공이 최고 

