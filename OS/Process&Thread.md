## CPU & 프로세스 & 쓰레드

**CPU(프로세서) & 코어**

- 코어는 명령어를 받아서 처리하는 하드웨어. 즉, 연산장치
- CPU는 코어, 레지스터 셋을 보유하고 있다. PCB, TCB의  PC, SP등의 레지스터 값을 CPU의 레지스터 셋에 복사. 실제로 Context Switching이 동작하는 방식.
    - PC(Program Counter): 다음에 수행할 명령어 위치 값을 저장.
    - SP(Stack Pointer): 콜 스택의 최상단 위치 값을 저장.
    - Context Switching: CPU 가상화의 핵심. 각 프로세스 or 쓰레드가 자신이 CPU를 독차지하고 있다는 환상을 갖게 하는 것.
- CPU에는 칩셋마다 다르지만 코어, 레지스터 셋, L1, L2 캐시등을 포함한다.

**프로그램**

- 프로그래밍 언어로 작성된 소스코드 or **기계어**(컴파일러에 의해 컴파일 된)등을 통칭해서 부름.
- **디스크에 적재**되어있음

**프로세스**

- 운영체제로부터 **독립된 메모리 공간을 할당** 받아 메모리에 적재된 프로그램. 즉, **실행이 가능한 상태의 프로그램.**
- task라고도 부름
- 할당 받는 메모리 공간은 Code, Data, Heap, Stack 세그먼트로 구분
    - Code: 소스코드. 즉 명령어(Instruction)가 위치한 공간
    - Data: 전역/정적 변수 저장 위치
    - **Heap**: 동적 할당 되는 메모리 위치.
    - **Stack**: 함수의 스택 프레임(지역변수, 매개변수, 리턴 값 등)을 구성할 때 사용함.
        - 기본적으로 정해진 크기가 있고, 이를 초과하면 **Stackoverflow** 에러가 발생.

**쓰레드**

- 프로세스의 메모리를 공유하며 **Stack, 레지스터 셋만 고유하게 할당**받는 코드의 흐름이다. 즉, **CPU를 사용하는 가장 기본 단위**이다.
- Stack, 레지스터 셋만 고유하게 사용하기 때문에, 하나의 프로세스에서 여러 쓰레드를 생성하는 경우 **경쟁 조건(Race Condition)**이 발생할 수 있다. 따라서 **동기화(Synchronization)**에 각별한 신경을 써줘야 한다.
- HWP(Heavy Weighted Process): 한 개의 쓰레드만 가진 프로세스
- **LWP**(Light Weighted Process): 두 개 이상의 쓰레드를 가진 프로세스

## 멀티코어(프로세서) vs 멀티프로세싱 vs 멀티쓰레딩

**멀티 코어**

- 멀티코어 프로그래밍은 **병렬성**에 초점이 맞춰져있다. CPU칩 안에 코어가 들어있고 여러개가 있으면 멀티코어. 즉 **물리적으로 동시**에 여러 명령어 처리가 가능해진다.
- 여러개의 코어를 제대로 사용하려면 여러개의 프로세스 or 쓰레드가 필요하고 이를 각각 코어에 배정해야 한다.
    - 멀티 프로세서 CPU 스케쥴링 알고리즘을 통해 배정.

**멀티 프로세싱**

- 멀티 프로세싱과 멀티 쓰레딩은 **동시성**에 초점이 맞춰져있다. 즉, 하나의 코어가 어떻게 여러 프로세스 or 쓰레드가 동시에 수행되는 것처럼 환상을 줄 수 있는지. CPU 가상화와 밀접한 연관이 있다.
- 프로세스는 모든 자원을 개별적으로 할당 받기 때문에 메모리 관점에서 안전하다. 메모리 침범 문제를 OS가 관리하기 때문에 프로세스끼리 서로 상대의 메모리를 침범할 일이 없다.
    - 프로세스끼리는 IPC(Inter Process Communication)를 통해 통신.
        - 파이프, named 파이프, 공유메모리, 메세지 큐, 세마포어 등이 있다.
- 모든 자원을 개별적으로 할당 받기 때문에 `fork`, context switch의 시간이 쓰레드에 비해 오래 걸린다.
    - 컨텍스트 스위치를 할 때 PCB를 교체하게 되는데, TCB보다 더 많은 정보를 갖고 있어서 오버헤드가 더 크다.`PCB.size` > `TCB.size`
    - 또한, 페이지 테이블을 매번 교체해야 되서 느린 것. 쓰레드는 그럴 필요가 없다. 같은 페이지 테이블을 사용한다. 가상메모리 페이징과 연관이 있다.

**멀티 쓰레딩**

- 하나의 프로세스 안에 여러개의 쓰레드를 생성. 즉, 스택과 레지스터 셋만 새로 할당.
    - 웹 서버같이 코드는 동일한데 여러 요청을 각각 독립적으로 처리해야 할 경우 유용하게 쓰일 수 있다.
- 멀티 쓰레딩이 멀티 프로세싱보다 좋은 점
    - 응답성: 하나의 쓰레드가 block 상태가 되어도 다른 쓰레드가 이어서 실행할 수 있음. 프로세스라면 block상태로 기다림.
    - 자원 공유: 메모리 자원을 공유한다. IPC보다 비용이 적게 든다.
    - 경제적: 쓰레드생성 < 프로세스 생성, context switching도 가볍다. TCB < PCB
    - 멀티프로그래밍: 병렬성이 더 올라감.
- Thread-safe하게 구현하는 것이 중요하다.
    - Thread-safe하다는 것은, 여러 쓰레드에서 동시에 접근해서 코드를 실행해도 각 쓰레드가 모두 올바른 결과를 얻게 되는 것을 말함.
        - Re-entrancy: 어떤 함수가 한 쓰레드에 의해 호출되어 실행 중일 때, 다른 쓰레드가 그 함수를 호출하더라도 그 결과가 각각에게 올바로 주어져야 한다.
        - thread-local storage: 각 쓰레드에서만 접근 가능한 저장소를 사용. (Stack?) 이를 통해 동시 접근을 막는다. 공유 상태를 피할 수 없을 때 사용
        - mutex: 공유자원 사용할 때는 상호 배제가 이루어져야 함.
        - atomic operation: 공유자원에 접근할때, 락을 잡을때 등 원자적으로 처리. 도중에 컨텍스트 스위칭이 발생해서 락을 동시에 잡는 등의 문제를 발생시키지 않는다.
    - lock, Java에서는 Synchronized 키워드를 사용
        - lock을 사용하면 해당 block이 되어 성능이 저하되는 문제점. → 블락이 자주 되면 해당 타임 슬라이스동안 락을 얻기 위해 기다리느라 손해를 보거나, 다시 다른 쓰레드로 컨텍스트 스위칭이 되는 오버헤드가 때문.
- 하나의 쓰레드가 비정상 종료 되면 다른 쓰레드들도 전부 꺼질 수 있음
    - 하나의 쓰레드가 비정상 종료 되서 공유 메모리를 건들거나, 프로세스를 종료시키거나 하면 프로세스에 포함된 다른 모든 쓰레드가 꺼진다 → IE(인터넷 익스플로러의 탭)
    - 크롬의 탭은 멀티 프로세스라서 그럴일은 없다. 하지만 메모리는 엄청 잡아먹음. 메모리는 CPU와 달리 많이 사용한다고 파워를 더 잡아먹는 것은 아니다.
