## 메모리 가상화

**메모리 가상화**

- CPU 가상화와 같은 방식으로 실제 프로세스들은 하나의 메모리에서 특정 영역을 차지하고 있는 것이지만 각각 자신의 메모리가 있다고 착각하게 만드는 것.
- 여러 개의 프로세스들이 메모리의 일정 부분을 함께 사용하게 됨.(Memory sharing)

**메모리 가상화의 필요성**

- 초기의 컴퓨터의 메모리 구성: OS와 현재 사용 중인 프로그램. -> 프로세스의 수는 하나로, 프로그램을 동시에 하나만 실행했음.
- 요즘 컴퓨터는 여러 개의 프로그램을 동시에 실행함. -> 메모리 가상화를 하지 않고 메모리 공유를 한다면 여러 프로세스들이 한 번에 메모리에 존재할 때 보안상 문제 발생할 수 있음.

**메모리 가상화의 목표**

1. 투명성(Transparency)
  - OS는 실행 중인 프로그램이 메모리가 가상화된다는 사실을 모르게 해야함.
  - 프로그램은 마치 자신에게 하나의 독립적인 실제 메모리가 있는 것처럼 작동해야 함.

2. 효율성(Efficiency)
  - OS는 시간과 공간적 측면에서 효율적으로 가상화를 수행하도록 해야함.
  - 시간 효율을 위해 TLB와 같은 하드웨어 지원을 받아야 함.
  
3. 보안(Protection)
  - OS는 프로세스들로부터 프로세스를 보호하고 OS 자신도 프로세스로부터 보호해야 함.
  - 여러 프로세스들이 각각 자신의 주소 공간에만 접근할 수 있도록 해야함.

### 주소 공간과 주소 변환

**주소 공간(The Address Space)**

- 운영 체제가 프로세스들에게 나눠주기 위해 실제 메모리를 추상화한 메모리.
- 프로세스의 주소 공간에는 해당 프로세스의 코드(text), 전역 변수를 저장하는 공간(Data), 지역 변수를 저장하는 공간(Stack), 동적 할당받은 데이터를 저장하는 공간(Heap)이 있음.
- 프로세스는 자신의 주소 공간에만 접근해야 함. -> OS를 통해 제어해줌.

**동적 재배치(Dynamic Relocation)를 통한 주소 변환(Address Translation)**

- 주소 변환을 통해 하드웨어는 virtual address(가상 주소)를 physical address(실제 주소)로 변환함.
- 하드웨어의 지원을 받으며 OS가 제어하는 방식으로 구현.
- CPU에서 직접 실행되지만 특정 상황에서 OS가 관여하는 Limited Direct Execution의 확장 개념.
- 주소 변환에서의 하드웨어의 역할
  - CPU에 2개의 하드웨어 레지스터(base, bounds(=limit))를 통해 실제 메모리의 원하는 위치에 프로세스의 가상 주소 공간 배치.
  - base는 실제 메모리에 재배치되었을 때 주소 공간의 시작 부분을, bounds는 그 주소 공간의 크기를 나타냄.
  - base, bounds 레지스터와 같이 주소변환을 돕는 프로세서 부분을 메모리 관리 장치(MMU)라고 부름.
- 주소 변화에서의 OS의 역할
  - 프로세스 생성될 때 프로세스 주소 공간을 위한 공간을 실제 메모리에서 찾음.
  - 프로세스 종료되면 종료된 프로세스가 사용하던 메모리 공간을 다른 프로세스나 OS가 사용하기 위해 반환해서 사용 가능 목록에 넣고 정리함.
  - context switch가 발생할 때 프로세스의 주소 공간으로의 원활한 이동을 위해 base, limit 레지스터 정보를 저장하고 복원해줌.
  - 예외 발생 시 호출할 핸들러나 함수를 부팅 시 설치함으로써 제공.
 
 **동적 재배치를 통한 주소 변환 기술의 비효율성**
 
 - base, limit 레지스터만 사용하는 경우 연속적으로 메모리에 할당해야 하기 때문에 할당된 메모리의 stack, heap 사이에 사용되지 않는 공간이 클 경우 메모리 낭비 발생. -> segmentation을 통한 base, limit 일반화로 개선 가능.
 
 **Segmentation(분할)를 통한 주소 변환**
 
 - 메모리의 일정 부분인 code, stack, heap을 segment와 그 base, limit 레지스터 쌍들을 담은 segment 레지스터를 통한 주소 변환.
 - 프로세스의 free 공간을 참조하려 하면 OS를 통해 해당 프로세스 종료 가능. -> segmentation fault!
 - 실제 메모리에 존재하던 segment가 확장할 수도 있고 너무 큰 여유공간에 작은 segment가 들어가서 메모리 공간의 비효율이 발생할 수 있음. -> 외부 단편화(external fragmentation)
 - 외부 단편화는 메모리 압축을 통해 해결할 수 있지만, 비용이 너무 크게 듬.
 - 외부 단편화를 없앨 수는 없지만, 최소화할 수 있는 free-list management algorithm을 사용할 수 있음.(best-fit, worst-fit, first-fit, next-fit)
 
 ## Paging
 
 **Paging**
 
 - segmentation의 외부 단편화를 해결하기 위한 방법.
 - 프로세스의 가상 주소 공간을 가변 크기가 아닌 고정 크기로 나눠 메모리에 할당하는 아이디어.
 - 가상공간에서 나누어진 고정 크기 단위는 page, page가 실제 메모리에 할당한 부분은 page frame이라는 단위로 씀.
 - segmentation에 비해 유연성, 여유 공간의 단순함이라는 장점을 지님.
 - 모든 프로세스가 프로세스의 page들이 실제 메모리의 어디에 위치하는지 기억하는 page table을 가지고 있어야 함. -> page table을 통해 주소 변환.
 - 가상 페이지 번호(VPN)과 offset을 통해 실제 프레임 번호(PFN)를 얻을 수 있음.
 
 **page table**
 
 - 가상 주소를 실제 메모리 주소로 변환해줄 때 사용하는 자료구조.
 - page table은 OS 가상 메모리에 저장되며, 디스크로 swap될 수도 있음.
 
 **paging의 문제점**
 
 - 주소 변환을 위한 메모리 접근이 너무 잦고, page table을 위한 메모리도 할당해야 하기 때문에 메모리 낭비도 발생. -> 성능 저하!
 
 **TLB(Translation Lookaside Buffers)**
 
 - TLB에서 물리 메모리 주소로 바로 변환해주는 cache.
 - 최근에 쓴 데이터를 자주 쓸 확률이 높고(Temporal), 주변에 있는 데이터를 같이 사용할 확률이 높은(Spatial) 성질에 따라 TLB hit rate를 높임.
