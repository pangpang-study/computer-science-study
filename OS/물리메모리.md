# 기본 하드웨어
- cpu가 직접 접근할 수 잇는 유일한 범용 저장장치 : 메인메모리 , 각 코어의 레지스터
- 실행되는 명령어는 메인메모리와 각 코어의 레지스터에 위치해야 접근이 가능, 그렇지 않다면 메모리로 이동 필요
- 레지스터는 1clock 안에 접근가능 ,하지만 메인메모리는 문제가 있다. 
- 필요한 데이터가 없어서 명령어 수행을못하여 stall(지연)이 발생한다. 
    - 해결방법 : 캐시 , 

# 프로그램 간의 메모리 접근 보호
- 물리메모리에 접근하는 상대적인 속도차이를 고려해야 올바른 동작을 보장한다. 
- 보호해야 하는 영역 : 운영체제로 부터 사용자 프로그램을 보호 , 사용자 프로그램 과 사용자 프로그램 간의 보호

- 보호하는 방법의 예 : 프로세스간의 독립된 메모리 공간 보장 
- 병행실행을 위한 합법적인 메모리 주소영역 설정 (base, limit이라고 불리는 제리스터로 물리메모리 값 지정)
- 운영체제의 영역이나 다른 프로그램의 코드를 접근하게 되면 trap 발생

- 운영체제가 cpu와 메모리 간의 접근 중에 개입하게 되면 성능이 떨어지기 때문에 보호 기법은 반드시 하드웨어가 지원해야 함

# 주소 공간을 이해하기 위한 바인딩 개념 
- 각 시간동안 주소들의 표현방식이 달라진다.
- 컴파일 시간 : 프로세스가 메모리 내에 들어갈 위치를 정할 수 있다면 절대코드를 생성할 수 있다. (R번지 부터 코드가 위치해야 한다면? -> 미리 생성)
- 적재시간 : 만약 컴파일 시점에 위치를 알지 못하면? -> 재배치 가능코드(이진코드)로 만들어서 실제 번지수와 해당 이진코드의 바인딩은 메인메모리로 올리는 시점에 이뤄진다. 
- 실행시간 :  런타임을 뜻하며 세그먼트 변경을 위해서는 하드웨어 지원 필요

# 논리 대 물리 주소공간 
- cpu 가 생성하는 주소 : 논리 주소 == 가상 주소 
- 메모리(메모리 주소 레지스터)가 취급하게 되는 주소 : 물리 주소 

- 컴파일 시간 , 적재시간 중의 주소 바인딩 -> 논리 주소 = 물리 주소 
- 실행시간 중의 주소 바인딩 -> 논리주소 != 물리 주소 
- 프로그램의 의해 생성된 모든 논리 주소 집합 : 논리 주소 공간
- 이 논리 주소과 일치하는 모든 물리 주소 집합 : 물리 주소 공간 

## 프로그램 실행 중 가상주소를 물리주소고 바꾸어주는 장치 : MMU
- 아까 말한 base 레지스터를 이제 재배치 레지스터라고 부른다. 
- 해당 레지스터안에 값은 주소가 메모리로 보내질 때마다 모든 주고에 더해진다. 


# 동적 적재 
- 프로세스가 실행되기 위해서는 프로세스가 메모리에 올라와 있어야 하지만 한계 있음 
- 동적으로 올려야 한다. 
- 동적 적재에서는 호출되기 전까지 재배치 가능상태로 대기 -> main프로그램 메모리 적재 후 실행 -> 다른 루틴 호출 -> 메모리에 적재여부 확인 (없다면?)-> 재배치 가능 연결 적재기가 불려 해당 루틴을 메모리로 가져온다. 
- 장점 : 필요한 경우에만 메모리에 적재 , 오류처리, 간혹발생하면서도 실행할 코드가 많은 경우에 유용
- 동적적재는 운영체제로 부터의 지원이 필요하지 않다.  설계자의 책임!!

# 동적 연결 , 동적 연결 라이브러리
## 동적 연결 라이브러리는 사용자 프로그램이 실행될 때 , 사용자 프로그램에 연결되는 시스템 라이브러리 
- 동적 적재 : 적재(loading)가 실행시 까지 미뤄짐 
- 동적 연결 : 연결(linking)이 실행시 까지 미뤄짐

### 장점 
- 시스템라이브러리가 없으면? -> 각 언어 라이브러리 사본을 일일히 넣어줘야됨
- 라이브러리를 여러 프로세스간의 공유할 수 있어 메인 메모리에 DLL 인스턴스가 하나만 있을 수 있다. --> 동적 공유 라이브러리라고 불리는 이유 
- 프로그램이 동적 라이브러리에 있는 루틴을 참조하면 로더는 DLL을 찾아 필요한 경우 적재하고 DLL의 함수를 참조하는 주소를 DLL이 저장된 메모리의 위치로 조정한다. 
- 갱신을 통한 확장 : 라이브러리만 바꾸면 새버전 , 오류 수정 가능

### 동적 연결 라이브러리는 운영체제의 도움 필요
- 프로세스들이 각자의 공간을 보호받음, 루틴 검사 , 메모리 주소 공유 (페이징)

# 연속 메모리 할당 
- cpu 스케쥴러에 의해서 수행할 프로세스가 선택되었을때 디스패쳐가 문맥교환을 위한 재배치 레지스터와 상한 레지스터에 정확한 값을 적재함
- 재배치 레지스터를 통해 언제든지 실행중인 프로그램을  변경할 수 있다. 
## 그럼 메모리 할당은? 
- 프로세스를 메모리의 가변 크기 파티션에 할당 
- 만약 프로세가 시스템에 들어오면 cpu를 할당받기 위해서 경쟁한다. 
- 그후에 할당받지 못한 프로세스들은 대기큐에 남아있고 메모리 해제시에 운영체제가 이 큐를 검사하여 큐의 프로세스를 할당할지 결정한다. 
- 그런데 이때 다양한 크기의 hole이 메모리에 여기저기 산재되어있기 때문에   운영체제는 이 hole의 집합에서 찾고 만약 크기가 더 크면 조각을 나누어 하나는 할당하고 나머지는 hole 집합으로 돌아간다. 

## 그럼 어떻게 가용 공간을 할당해 줄것이고 만족시킬것인가?
- 최초적합 (first-fit) : 사용가능한 가용공간을 할당 , 검색은 집합의 시작에서부터 하거나 마지막으로 검색이 끝난곳부터 시작 , 충분히 큰 공간 찾으면 바로 검색 종료 
- 최적 적합(best-fit) : 사용가능한 공간중 가장 작은 공간 검색 
- 최악 적합(worst-fit) : 가장 큰 가용공간 택함

--> 시간, 메모리 효율 : 최악 적합 << 최초적합, 최적적합

--> 속도 : 일반적으로는 최초적합 << 최적적합 

# 단편화 
- 최초적합, 최적적합 모두 **외부 단편화**로 어려움을 겪음
- 매우 작은 가용공간들이 분산되어있지만 충분하지 못하여 분산되어 생김
- 따라서 최초,최적은 단편화의 크기에 따라 선택 , 또한 어느쪽에서 부터 가용공간을 할당하지 고려해야함 (그래도 생김)
- 할당된 공간과 요구된 공간간의 남는 **내부 단편화** 
- 해결방법 : 압축 --> 모든 내용을 한군대로 몰고 가용공간을 따로 몰아서 사용(비용이 너무 많이 든다.)

# 페이징(기본적인 방법)
- 외부 단편화 문제를 해결하기 위해 논리 주소 곤간을 여러개의 비연속적인 공간으로 나누어 필요한 크기이 공간이 가용해지는 경우 해당 프로세스를 할당함
- 대형 서버용 시슽템, 모바일 장치용 시스템등 다양한 형태의 페이징 사용
- 운영체제와 컴퓨터 하드웨어 간의 협력을 통해 구현 

## 프레임 : 물리 메모리가 나누어지는 같은 크기 블록 
## 페이지 : 논리 메모리가 나누어지는 같은 크기 블록 

- cpu에서 나오는 모든 주소는 페이지 번호와 offset으로 구성
- 페이징기법을 사용하면 외부 단편화는 안생기지만 내부 단편화는 생인다. 
- why? -->정수배로 할당되기 때문에 
- 그럼 페이지크기가 작으면 되는거 아닌가? --> 테이블이 차지하는 공간이 낭비 
- 디스크 입장에서는 페이지 클수록 효율적 
- 운영체제는 모든 프로세스의 주소를 실제 주소로 바꿀 수 있어야 한다. 
- 프레임테이블은 시스템에 하나밖에 없는 자료구조 , 페이지 테이블은 프로세스별 자료구조 


## 하드웨어지원 
- 메인 메모리에 페이지 테이블을 저장하여 문맥교환을 빠르게 할 수 있지만 메모리 액세스 관점에서 매우 느리다. 
- 메모리 i 액세스 원함 -> 페이지 번호를 지군으로 페이지 테이블 기준 레지스터의 offset값을 사용하여 테이블 검색(메모리 액세스 1) -> 해당 프레임번호 + offset 을 통해 생성된 실제 주소로 액세스 (메모리 액세스 2)

## TLB
- 이를 해결하기 위한 소영 하드웨어 캐시 
- 구성 : key, value
- TLB에 페이지 검색 요청이 들어오면 페이지 번호가 같은 것을 검색해서 해당 프레임 번호를 알려준다. 
- 검색 하는 속도는 파이프 라인의 이부로 동작 --> 크게 손해 없음 
- 페이지 테이블과 함께 사용하며 일부분을 저장하여 cpu가 논리 주소를 생성 -> MMU는 해당 번호 TLB에 있는지 확인 -> 있으면 해당 프레임 번호로 메모리 접근 
- 페이지 테이블과 함께 사용하며 일부분을 저장하여 cpu가 논리 주소를 생성 -> MMU는 해당 번호 TLB에 있는지 확인 -> 없으면 miss -> 기본방법으로 찾는다. -> TLB에 추가한다. 
- TBL가 가득 차면? -> 교체 정책의 의해서 교체 , LRU,Round Robbin , emdemd
- 특정 코드들은 TLB 고정


## 보호 
- 페이징 환경에서 페이지에 붙어있는 보호비트에 의해 구현
- 읽고 쓰기 등의 권한을 부여하거나 확인 
- 각 엔트리에는 유효, 무효 비트가 위의 비트 이외에 추가적으로 존재

## 공유 페이지
- 페이징은 공통의 코드를 공유할 수 있다는 장점이 있다. 
- 재진입 코드 같은 경우에는 절대 변결되지 않는다면 두개 이상의 코드를 동시에 실행할 수 있다. 
- 각 프로세스는 데이터 보유를 위한 자체 레지스터 사본과 데이터 저장 -> 두개의 프로세스가 가진 데이터는 다르다. -> 라이브러리는 하나의 사본만 저장 , 각 프로세스의 페이지테이블은 동일한 사본이 하나만 필요 ****
- 프로세스간의 상호 통신의 방법으로 메모리 공유가 사용된다. 

# 페이지 테이블 구성방식
1. 계층적 페이징 
- 2단계 페이징 기법 : 페이지 테이블 자체를 다시 페이징한다. 
- 20bit 페이지 번호 + 페이지 offset
- 20bit = 바깥 페이지 테이블 인덱스 10bit + 안쪽 페이지 테이블 페이지 offset
- 동일한 방법으로 3단계도 가능 

2. 해시 페이지 테이블 
- 주소공간이 32비트보다 커지면 가상 주소를 해시로 사용 
- 가상 주소공간으로 부터 페이지 번호 들어옴 -> 해싱 -> 해시 페이지 테이블에서 연결리스트 따라간다. -> 일치하면 해당 페이지 프레임 번호를 가져와 물리주소 얻는다. 

3. 역 페이지 테이블 
- 프로세스가 각자 페이지 테이블을 가지 고 있다면 프로세스는 페리이즤 가상주소를 통해 참조하면되지만 이를 운영체제가 물리로 바꾸는 것은 빨라보이지만 개수가 늘어남에 따라 메모리의 부하가 걸린다. 
- 따라서 이를 해결하기 위해서 페이지 테이블에서 메모리 프레임 마다 해당 프레임에 올라와있는 페이지 주소 , 프로세스 ID를 표시한다. 
- 하나의 페이지 테이블로 프로세스 관리 가능 
- 각각 페이지 테이블 엔트리에 저장되는 주소 공간 ID를 저장하여 어떤 프로세스가 그 논리 페이지에 사상되었는지 보장한다. 
- 하지만 주소변환이 오래걸리고 메모리 참조회수를 증가 시킨다.(해시 테이블 , 페이지 테이블 , 해시 테이블 이전에 TLB참조)

4. 스와핑 
- 프로세스는 명령어나 데이터가 메모리에 있어야 한다. 
- 하지만 일부분은 백업저장장치로 갔다가 되돌린다. 
- 프로세스의 필요 물리주소 공간 총합이 시스템 메모리보다 커도 동시실행 가능
- 수용크기가 충분히 커야 한다. 
- 백업되거나 스왑될때 메타데이터도 스왑 되어야 함
    ## 페이징에서의 스와핑 
    - 표준 스와팅은 이제 안씀 -> 프로세스 전체 이동 cost
    - linux, windows 등등 전체가 아닌 페이지스왑
    - 페이지를 메모리 to 백업 저장장치  = 페이지 아웃 
    - 반대의 연산 = 페이지 인

