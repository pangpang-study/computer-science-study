## 컴파일러와 인터프리터

**컴파일러 - 하드웨어에 종속적**

인터프리터에 비해 기계어로의 번역시간은 오래걸리지만, 런타임 이전에 한번에 번역을 실행하여 다음에 실행을 할 때 기존에 생성되었던 실행 파일을 실행하기에, 인터프리터에 비해 실행시간이 빠르다.

바로 기계어로 변환하는 컴파일러는 프로그램이 작성된 기계상에서 실행할때 매우 효율적이다. 대부분의 하드웨어 제어 시스템이 프로그래밍 언어가 C언어인 이유이다.



**인터프리터  - 모든 플랫폼에 종속되지 않음** 

런타임에서 한줄 한줄 기계어로 번역을 진행하기에 컴파일러에 비해 번역시간은 빠르지만, 실행속도가 느리다.



#### JAVA 컴파일러가 하는 일?

###### Java는 왜 컴파일러와 인터프리터를 병행해서 사용할까?

자바의 기본원칙 WORA ( Write Once, Run Anywhere) 을 지키기 위함으로 볼 수 있다.

![image-20211206131837277](https://user-images.githubusercontent.com/12428689/144792222-105b852b-bdeb-48ba-88ad-7e8bf8cef42b.png)

**컴파일의 영역**

- helloworld.java 파일을 **java compiler**(javac compiler)를 이용하여 0과 1로 이루어진 helloworld.class(Byte code)로 변환
- 컴파일러가 **소스코드를 오브젝트코드**(.class)로, **고레벨 언어를 저레벨 언어**인 기계어로 변환한다.
  여기서의 기계는 하드웨어가 아니다. **JVM**을 위해 기계어로 변환한다는 것이다.

**JVM의 영역**

- helloworld.class(Byte code)를 JVM의 <u>**클래스 로더**</u>에게 전달한다. 그 후, 필요한 클래스들을 로딩, 링크하여 런타임 영역, 즉 JVM 메모리 영역에 올린다.
- <u>**실행엔진**</u>은 JVM 메모리 영역에 있는 바이트 코드를 명령어 단위로 하나씩 가져와서 실행한다. 
- helloworld.class 파일을 **<u>java interpreter</u>**를 이용하여 machine language로 변환

여기서 볼 수 있듯이 자바는 이러한 추가적인 단계를 거치기에 다른 언어보다 cpu에게 전달하는 속도가 느리다. 

이를 극복하기위해 인터프리터의 단점을 보완하기 위해 도입된 JIT 컴파일러를 인터프리터와 함께 사용한다.



#### JVM이란?

- 인터프리터 -  .class의 바이트코드를 해당 하드웨어의 환경에 맞게 변환하여 ***운영체제에 종속적이지 않게*** 만들어줌
- 클래스 로더 - 컴파일러가 SSD 내부에 만들어놓은 .class 파일을 읽어온다
- 실행 엔진(JIT 컴파일러 포함) - .class 파일을 읽으면서 static 선언을 한 메서드, 변수를 찾는다. 여기서 JIT 컴파일러는 인터프리터가 번역하는 기계어들 중에서 자주 사용되는 코드 부분을 기계어로 캐싱하여, 또 다시 호출하였을 때 인터프리터가 아닌, JIT 컴파일러가 기계어로 변환해 놓은 캐시에서 꺼내 사용한다.
- 가비지 컬렉터 - 메모리를 자동으로 회수한다.

